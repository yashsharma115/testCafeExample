"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = exports.startOnDocker = exports.start = void 0;
const testcafe_browser_tools_1 = __importDefault(require("testcafe-browser-tools"));
const process_1 = require("../../../../../utils/process");
const browser_starter_1 = __importDefault(require("../../../utils/browser-starter"));
const build_chrome_args_1 = require("./build-chrome-args");
const chrome_remote_interface_1 = __importDefault(require("chrome-remote-interface"));
const timer_1 = __importDefault(require("../../../../../utils/timer"));
const delay_1 = __importDefault(require("../../../../../utils/delay"));
const browserStarter = new browser_starter_1.default();
const LIST_TABS_TIMEOUT = 10000;
const LIST_TABS_DELAY = 500;
async function start(pageUrl, { browserName, config, cdpPort, tempProfileDir, isContainerized, isNativeAutomation }) {
    const chromeInfo = await testcafe_browser_tools_1.default.getBrowserInfo(config.path || browserName);
    const chromeOpenParameters = Object.assign({}, chromeInfo);
    chromeOpenParameters.cmd = (0, build_chrome_args_1.buildChromeArgs)({ config, cdpPort, platformArgs: chromeOpenParameters.cmd, tempProfileDir, isContainerized, isNativeAutomation, browserName });
    await browserStarter.startBrowser(chromeOpenParameters, pageUrl);
}
exports.start = start;
async function tryListTabs(cdpPort) {
    try {
        return { tabs: await chrome_remote_interface_1.default.List({ port: cdpPort }) };
    }
    catch (error) {
        return { error };
    }
}
async function startOnDocker(pageUrl, { browserName, config, cdpPort, tempProfileDir, isContainerized }) {
    await start('', { browserName, config, cdpPort, tempProfileDir, isContainerized });
    let { tabs, error } = await tryListTabs(cdpPort);
    const timer = new timer_1.default(LIST_TABS_TIMEOUT);
    //NOTE: We should repeat getting 'List' after a while because we can get an error if the browser isn't ready.
    while ((error || !tabs.length) && !timer.expired) {
        await (0, delay_1.default)(LIST_TABS_DELAY);
        ({ tabs, error } = await tryListTabs(cdpPort));
    }
    if (error)
        throw error;
    const target = tabs.filter(t => t.type === 'page')[0];
    const { Target } = await (0, chrome_remote_interface_1.default)({ target, port: cdpPort });
    await Target.createTarget({ url: pageUrl });
    await chrome_remote_interface_1.default.Close({ id: target.id, port: cdpPort });
}
exports.startOnDocker = startOnDocker;
async function stop({ browserId }) {
    // NOTE: Chrome on Linux closes only after the second SIGTERM signall
    if (!await (0, process_1.killBrowserProcess)(browserId))
        await (0, process_1.killBrowserProcess)(browserId);
}
exports.stop = stop;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtY2hyb21lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Jyb3dzZXIvcHJvdmlkZXIvYnVpbHQtaW4vZGVkaWNhdGVkL2Nocm9tZS9sb2NhbC1jaHJvbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0ZBQWtEO0FBQ2xELDBEQUFrRTtBQUNsRSxxRkFBNEQ7QUFDNUQsMkRBQXNEO0FBQ3RELHNGQUFtRDtBQUNuRCx1RUFBK0M7QUFDL0MsdUVBQStDO0FBRS9DLE1BQU0sY0FBYyxHQUFHLElBQUkseUJBQWMsRUFBRSxDQUFDO0FBRTVDLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLE1BQU0sZUFBZSxHQUFLLEdBQUcsQ0FBQztBQUV2QixLQUFLLFVBQVUsS0FBSyxDQUFFLE9BQU8sRUFBRSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsa0JBQWtCLEVBQUU7SUFDdkgsTUFBTSxVQUFVLEdBQWEsTUFBTSxnQ0FBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDO0lBQzNGLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFM0Qsb0JBQW9CLENBQUMsR0FBRyxHQUFHLElBQUEsbUNBQWUsRUFBQyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFFMUssTUFBTSxjQUFjLENBQUMsWUFBWSxDQUFDLG9CQUFvQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFQRCxzQkFPQztBQUVELEtBQUssVUFBVSxXQUFXLENBQUUsT0FBTztJQUMvQixJQUFJO1FBQ0EsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGlDQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQztLQUMvRDtJQUNELE9BQU8sS0FBSyxFQUFFO1FBQ1YsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO0tBQ3BCO0FBQ0wsQ0FBQztBQUVNLEtBQUssVUFBVSxhQUFhLENBQUUsT0FBTyxFQUFFLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRTtJQUMzRyxNQUFNLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUVuRixJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pELE1BQU0sS0FBSyxHQUFXLElBQUksZUFBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFbkQsNkdBQTZHO0lBQzdHLE9BQU8sQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQzlDLE1BQU0sSUFBQSxlQUFLLEVBQUMsZUFBZSxDQUFDLENBQUM7UUFFN0IsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ2xEO0lBRUQsSUFBSSxLQUFLO1FBQ0wsTUFBTSxLQUFLLENBQUM7SUFFaEIsTUFBTSxNQUFNLEdBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUQsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE1BQU0sSUFBQSxpQ0FBWSxFQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBRWpFLE1BQU0sTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLE1BQU0saUNBQVksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztBQUMvRCxDQUFDO0FBckJELHNDQXFCQztBQUVNLEtBQUssVUFBVSxJQUFJLENBQUUsRUFBRSxTQUFTLEVBQUU7SUFDckMscUVBQXFFO0lBQ3JFLElBQUksQ0FBQyxNQUFNLElBQUEsNEJBQWtCLEVBQUMsU0FBUyxDQUFDO1FBQ3BDLE1BQU0sSUFBQSw0QkFBa0IsRUFBQyxTQUFTLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBSkQsb0JBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYnJvd3NlclRvb2xzIGZyb20gJ3Rlc3RjYWZlLWJyb3dzZXItdG9vbHMnO1xuaW1wb3J0IHsga2lsbEJyb3dzZXJQcm9jZXNzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvcHJvY2Vzcyc7XG5pbXBvcnQgQnJvd3NlclN0YXJ0ZXIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvYnJvd3Nlci1zdGFydGVyJztcbmltcG9ydCB7IGJ1aWxkQ2hyb21lQXJncyB9IGZyb20gJy4vYnVpbGQtY2hyb21lLWFyZ3MnO1xuaW1wb3J0IHJlbW90ZUNocm9tZSBmcm9tICdjaHJvbWUtcmVtb3RlLWludGVyZmFjZSc7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvdGltZXInO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2RlbGF5JztcblxuY29uc3QgYnJvd3NlclN0YXJ0ZXIgPSBuZXcgQnJvd3NlclN0YXJ0ZXIoKTtcblxuY29uc3QgTElTVF9UQUJTX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IExJU1RfVEFCU19ERUxBWSAgID0gNTAwO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnQgKHBhZ2VVcmwsIHsgYnJvd3Nlck5hbWUsIGNvbmZpZywgY2RwUG9ydCwgdGVtcFByb2ZpbGVEaXIsIGlzQ29udGFpbmVyaXplZCwgaXNOYXRpdmVBdXRvbWF0aW9uIH0pIHtcbiAgICBjb25zdCBjaHJvbWVJbmZvICAgICAgICAgICA9IGF3YWl0IGJyb3dzZXJUb29scy5nZXRCcm93c2VySW5mbyhjb25maWcucGF0aCB8fCBicm93c2VyTmFtZSk7XG4gICAgY29uc3QgY2hyb21lT3BlblBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBjaHJvbWVJbmZvKTtcblxuICAgIGNocm9tZU9wZW5QYXJhbWV0ZXJzLmNtZCA9IGJ1aWxkQ2hyb21lQXJncyh7IGNvbmZpZywgY2RwUG9ydCwgcGxhdGZvcm1BcmdzOiBjaHJvbWVPcGVuUGFyYW1ldGVycy5jbWQsIHRlbXBQcm9maWxlRGlyLCBpc0NvbnRhaW5lcml6ZWQsIGlzTmF0aXZlQXV0b21hdGlvbiwgYnJvd3Nlck5hbWUgfSk7XG5cbiAgICBhd2FpdCBicm93c2VyU3RhcnRlci5zdGFydEJyb3dzZXIoY2hyb21lT3BlblBhcmFtZXRlcnMsIHBhZ2VVcmwpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cnlMaXN0VGFicyAoY2RwUG9ydCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHRhYnM6IGF3YWl0IHJlbW90ZUNocm9tZS5MaXN0KHsgcG9ydDogY2RwUG9ydCB9KSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydE9uRG9ja2VyIChwYWdlVXJsLCB7IGJyb3dzZXJOYW1lLCBjb25maWcsIGNkcFBvcnQsIHRlbXBQcm9maWxlRGlyLCBpc0NvbnRhaW5lcml6ZWQgfSkge1xuICAgIGF3YWl0IHN0YXJ0KCcnLCB7IGJyb3dzZXJOYW1lLCBjb25maWcsIGNkcFBvcnQsIHRlbXBQcm9maWxlRGlyLCBpc0NvbnRhaW5lcml6ZWQgfSk7XG5cbiAgICBsZXQgeyB0YWJzLCBlcnJvciB9ID0gYXdhaXQgdHJ5TGlzdFRhYnMoY2RwUG9ydCk7XG4gICAgY29uc3QgdGltZXIgICAgICAgICA9IG5ldyBUaW1lcihMSVNUX1RBQlNfVElNRU9VVCk7XG5cbiAgICAvL05PVEU6IFdlIHNob3VsZCByZXBlYXQgZ2V0dGluZyAnTGlzdCcgYWZ0ZXIgYSB3aGlsZSBiZWNhdXNlIHdlIGNhbiBnZXQgYW4gZXJyb3IgaWYgdGhlIGJyb3dzZXIgaXNuJ3QgcmVhZHkuXG4gICAgd2hpbGUgKChlcnJvciB8fCAhdGFicy5sZW5ndGgpICYmICF0aW1lci5leHBpcmVkKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5KExJU1RfVEFCU19ERUxBWSk7XG5cbiAgICAgICAgKHsgdGFicywgZXJyb3IgfSA9IGF3YWl0IHRyeUxpc3RUYWJzKGNkcFBvcnQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yO1xuXG4gICAgY29uc3QgdGFyZ2V0ICAgICA9IHRhYnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAncGFnZScpWzBdO1xuICAgIGNvbnN0IHsgVGFyZ2V0IH0gPSBhd2FpdCByZW1vdGVDaHJvbWUoeyB0YXJnZXQsIHBvcnQ6IGNkcFBvcnQgfSk7XG5cbiAgICBhd2FpdCBUYXJnZXQuY3JlYXRlVGFyZ2V0KHsgdXJsOiBwYWdlVXJsIH0pO1xuICAgIGF3YWl0IHJlbW90ZUNocm9tZS5DbG9zZSh7IGlkOiB0YXJnZXQuaWQsIHBvcnQ6IGNkcFBvcnQgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9wICh7IGJyb3dzZXJJZCB9KSB7XG4gICAgLy8gTk9URTogQ2hyb21lIG9uIExpbnV4IGNsb3NlcyBvbmx5IGFmdGVyIHRoZSBzZWNvbmQgU0lHVEVSTSBzaWduYWxsXG4gICAgaWYgKCFhd2FpdCBraWxsQnJvd3NlclByb2Nlc3MoYnJvd3NlcklkKSlcbiAgICAgICAgYXdhaXQga2lsbEJyb3dzZXJQcm9jZXNzKGJyb3dzZXJJZCk7XG59XG4iXX0=